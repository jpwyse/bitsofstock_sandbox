"""
Django Ninja REST API endpoints for the crypto trading sandbox.

This module defines all RESTful API endpoints using django-ninja, providing portfolio
management, trading, market data, news, and user account functionality. All endpoints
return JSON responses with automatic schema validation.

API Categories:
    - Portfolio: /portfolio/* - Portfolio summary, historical values
    - Holdings: /holdings - Current cryptocurrency positions
    - Cryptocurrencies: /cryptocurrencies/* - Available assets and market data
    - Trading: /trades/* - Buy/sell order execution
    - Transactions: /transactions - Historical trade records with pagination
    - News: /news/* - Cryptocurrency news from Finnhub
    - User: /user/* - Account information and profile
    - Market: /price_history - Historical price data via yfinance

Common Patterns:
    - Demo user: All endpoints use User.objects.first() (sandbox assumption)
    - Error handling: HttpError(status_code, message) for client/server errors
    - Schemas: Pydantic-based request/response validation (see trading/schemas.py)
    - Pagination: PageNumberPagination for transaction history (20 per page)
    - UUID serialization: All model IDs converted to strings

Error Codes:
    - 400 Bad Request: Invalid input (e.g., invalid timeframe, missing required fields)
    - 404 Not Found: Resource doesn't exist (e.g., user, cryptocurrency, holding)
    - 502 Bad Gateway: Upstream service failure (CoinGecko, Finnhub, yfinance)

External Service Dependencies:
    - CoinGeckoService: Real-time prices, historical data, coin info
      • Rate limits: Free tier ~10-50/min, Pro tier ~500/min
      • Endpoints: /cryptocurrencies/*, /portfolio/history
    - FinnhubService: Cryptocurrency news articles
      • Rate limits: Free tier 60/min, Premium higher
      • Endpoints: /news/crypto
    - yfinance: Historical price/volume data for charting
      • Rate limits: None documented (Yahoo Finance)
      • Endpoints: /price_history

Security Notes:
    - API keys kept server-side (settings.py)
    - No API key exposure to frontend clients
    - Demo user: Authentication not enforced (sandbox)

Timezone Handling:
    - All datetime fields timezone-aware (USE_TZ=True)
    - Serialized as ISO 8601 with timezone offset
    - UNIX timestamps (int) used for external API compatibility

Performance:
    - select_related/prefetch_related for N+1 query prevention
    - Price caching in services layer (CoinGecko)
    - Pagination for large result sets (transactions)

Deployment:
    - Heroku: Full-stack deployment (frontend + backend together)
    - API root: /api/ (configured in crypto_sandbox/urls.py)

Notes:
    - Frontend consumes via Axios (frontend/src/services/apiAxios.js)
    - All endpoints support CORS (configured in settings.py)
    - OpenAPI/Swagger docs auto-generated by django-ninja
"""
from ninja import Router, Query
from ninja.errors import HttpError
from ninja.pagination import paginate, PageNumberPagination
from django.shortcuts import get_object_or_404
from decimal import Decimal
from typing import List, Optional
from datetime import datetime
import yfinance as yf
import pandas as pd

from trading.models import Portfolio, Cryptocurrency, Holding, Transaction, User
from trading.schemas import (
    PortfolioSummarySchema,
    PortfolioHistorySchema,
    HoldingsListSchema,
    HoldingSchema,
    CryptocurrencySchema,
    CryptocurrencyDetailSchema,
    TransactionListSchema,
    TransactionSchema,
    BuyRequestSchema,
    SellRequestSchema,
    TradeResponseSchema,
    NewsArticleSchema,
    MarketPricePointSchema,
    UserAccountSchema,
)
from trading.services.trading import TradingService
from trading.services.portfolio import PortfolioService
from trading.services.coingecko import CoinGeckoService
from trading.services.finnhub import FinnhubService
from trading.services.yfinance import YFinanceService
from trading.services.yfinance import fetch_price_history_payload

router = Router()

# Portfolio Endpoints

@router.get("/portfolio/summary", response=PortfolioSummarySchema, tags=["Portfolio"])
def get_portfolio_summary(request):
    """
    Get portfolio summary with valuation and performance metrics.

    Returns the user's portfolio overview including cash balance, holdings value, total
    portfolio value, and gain/loss metrics (both absolute and percentage).

    Endpoint:
        GET /api/portfolio/summary

    Response Schema:
        PortfolioSummarySchema - See trading/schemas.py:PortfolioSummarySchema

    Response Fields:
        - cash_balance (Decimal): Available USD cash (2 decimals)
        - total_holdings_value (Decimal): Market value of all crypto holdings (2 decimals)
        - total_portfolio_value (Decimal): cash_balance + total_holdings_value (2 decimals)
        - initial_investment (Decimal): Cost basis for P&L calculation (2 decimals)
        - total_gain_loss (Decimal): Unrealized P&L in USD (2 decimals)
        - total_gain_loss_percentage (Decimal): Unrealized return % (2 decimals)
        - last_updated (datetime): Timestamp of this response (timezone-aware)

    Error Codes:
        - 404: No user found (empty database)

    External Service Calls:
        - None (uses cached cryptocurrency.current_price from database)
        - Prices updated by background worker (update_prices.py management command)

    Performance:
        - Single database query via portfolio.holdings.all()
        - Holdings value computed via Portfolio.total_holdings_value property
        - No external API calls

    Example Response:
        {
            "cash_balance": "9250.50",
            "total_holdings_value": "3420.75",
            "total_portfolio_value": "12671.25",
            "initial_investment": "10000.00",
            "total_gain_loss": "2671.25",
            "total_gain_loss_percentage": "26.71",
            "last_updated": "2025-01-15T14:30:00Z"
        }

    Notes:
        - Used by Portfolio.js for dashboard header
        - total_gain_loss = total_portfolio_value - initial_investment
        - Demo user: User.objects.first() (sandbox assumption)
        - Real-time prices: Background worker updates cryptocurrency.current_price
    """
    # Get demo user's portfolio (hardcoded for sandbox)
    user = User.objects.first()
    if not user:
        raise HttpError(404, "No user found")

    portfolio = user.portfolio

    return {
        "cash_balance": portfolio.cash_balance,
        "total_holdings_value": portfolio.total_holdings_value,
        "total_portfolio_value": portfolio.total_value,
        "initial_investment": portfolio.initial_cash,
        "total_gain_loss": portfolio.total_gain_loss,
        "total_gain_loss_percentage": portfolio.total_gain_loss_percentage,
        "last_updated": datetime.now()
    }


@router.get("/portfolio/history", response=PortfolioHistorySchema, tags=["Portfolio"])
def get_portfolio_history(
    request,
    timeframe: str = Query(..., description="Timeframe: 1D, 5D, 1M, 3M, 6M, YTD")
):
    """
    Get historical portfolio values for performance charting with inception handling.

    Returns time-series data of portfolio values over the requested timeframe, using
    historical cryptocurrency prices from CoinGecko and reconstructing holdings from
    transaction history.

    Portfolio time-series are capped at YTD (year-to-date) as the maximum lookback.
    This restriction is portfolio-specific; market/asset charts may still support
    longer timeframes (1Y, 5Y, MAX).

    Endpoint:
        GET /api/portfolio/history?timeframe={timeframe}

    Query Parameters:
        - timeframe (str, required): One of 1D, 5D, 1M, 3M, 6M, YTD

    Supported Timeframes:
        - 1D: Last 24 hours (hourly intervals)
        - 5D: Last 5 days (hourly intervals)
        - 1M: Last 30 days (daily intervals)
        - 3M: Last 90 days (daily intervals)
        - 6M: Last 180 days (daily intervals)
        - YTD: Year-to-date (daily intervals)

    Response Schema:
        PortfolioHistorySchema - See trading/schemas.py:PortfolioHistorySchema

    Response Fields:
        - timeframe (str): Echoed timeframe parameter
        - data_points (List): Time-series data:
          [
              {
                  "timestamp": datetime (timezone-aware UTC),
                  "portfolio_value": Decimal (USD, 2 decimals)
              },
              ...
          ]

    Error Codes:
        - 400: Invalid timeframe parameter (not in supported list)
        - 404: No user found (empty database)
        - 502: CoinGecko service failure (upstream API down/rate limited)

    External Service Calls:
        - CoinGeckoService.get_historical_prices() for each unique cryptocurrency held
        - Rate limits: Free tier ~10-50 calls/min, Pro tier ~500 calls/min
        - 1 API call per unique crypto (batch fetching to minimize calls)

    Performance:
        - Batch fetches all crypto prices upfront (N CoinGecko API calls for N cryptos)
        - Caches prices in memory for time-series calculation
        - Incremental holdings reconstruction from transactions
        - Typical response time: 1-3 seconds for 30-day history with 5 cryptos

    Inception Handling:
        - Inception = min(first_transaction.timestamp, portfolio.created_at)
        - Pre-inception time points: Return initial_cash (flat value)
        - Post-inception time points: Return cash + mark-to-market holdings value
        - See services/portfolio.py for detailed inception logic

    Example Response:
        {
            "timeframe": "1M",
            "data_points": [
                {
                    "timestamp": "2025-01-01T00:00:00Z",
                    "portfolio_value": "10000.00"
                },
                {
                    "timestamp": "2025-01-02T00:00:00Z",
                    "portfolio_value": "10123.45"
                },
                ...
            ]
        }

    Notes:
        - Used by PortfolioPerformanceChart.js for Recharts line chart
        - Prices forward-filled (last observation carried forward)
        - Cash approximation: Uses current cash_balance for all time points (TODO: exact reconstruction)
        - Missing prices: Assets contribute $0 (non-blocking, logged as warning)
    """
    user = User.objects.first()
    if not user:
        raise HttpError(404, "No user found")

    portfolio = user.portfolio

    # PORTFOLIO-SPECIFIC: YTD is the maximum timeframe
    # (Market/asset endpoints may still use 1Y, 5Y, MAX)
    valid_timeframes = ['1D', '5D', '1M', '3M', '6M', 'YTD']
    if timeframe not in valid_timeframes:
        raise HttpError(400, f"Invalid timeframe. Must be one of: {', '.join(valid_timeframes)}")

    data_points = PortfolioService.calculate_portfolio_history(portfolio, timeframe)

    return {
        "timeframe": timeframe,
        "data_points": data_points
    }


# Holdings Endpoints

@router.get("/holdings", response=HoldingsListSchema, tags=["Holdings"])
def get_holdings(request):
    """
    Get all cryptocurrency holdings with P&L calculations.

    Returns the user's current cryptocurrency positions with quantity, cost basis,
    current value, and gain/loss metrics. Positions ordered by database ID.

    Endpoint:
        GET /api/holdings

    Response Schema:
        HoldingsListSchema - See trading/schemas.py:HoldingsListSchema

    Response Fields:
        - holdings (List): Array of holding objects:
          Each holding includes:
          • id (str): Holding UUID
          • cryptocurrency (object): Asset details (symbol, name, icon, current_price, volume, market_cap)
          • quantity (Decimal): Crypto amount held (8 decimals)
          • average_purchase_price (Decimal): Weighted average cost basis (8 decimals)
          • total_cost_basis (Decimal): Total USD invested (2 decimals)
          • current_value (Decimal): Market value (quantity × current_price, 2 decimals)
          • gain_loss (Decimal): Unrealized P&L in USD (2 decimals)
          • gain_loss_percentage (Decimal): Unrealized return % (2 decimals)

    Error Codes:
        - 404: No user found (empty database)

    External Service Calls:
        - None (uses cached cryptocurrency.current_price from database)
        - Prices updated by background worker (update_prices.py management command)

    Performance:
        - select_related('cryptocurrency') to prevent N+1 queries
        - Single database query with JOIN
        - P&L computed via Holding model properties (no additional queries)

    Example Response:
        {
            "holdings": [
                {
                    "id": "uuid-string",
                    "cryptocurrency": {
                        "id": "uuid-string",
                        "symbol": "BTC",
                        "name": "Bitcoin",
                        "icon_url": "https://...",
                        "current_price": "42000.00",
                        "volume_24h": "28500000000.00",
                        "market_cap": "820000000000.00"
                    },
                    "quantity": "0.15000000",
                    "average_purchase_price": "38000.00",
                    "total_cost_basis": "5700.00",
                    "current_value": "6300.00",
                    "gain_loss": "600.00",
                    "gain_loss_percentage": "10.53"
                },
                ...
            ]
        }

    Notes:
        - Used by Portfolio.js Holdings tab for position list
        - Empty array if no holdings (valid response, not an error)
        - P&L calculations: gain_loss = current_value - total_cost_basis
        - Demo user: User.objects.first() (sandbox assumption)
    """
    user = User.objects.first()
    if not user:
        raise HttpError(404, "No user found")

    portfolio = user.portfolio
    holdings = portfolio.holdings.select_related('cryptocurrency').all()

    holdings_data = []
    for holding in holdings:
        holdings_data.append({
            "id": str(holding.id),
            "cryptocurrency": {
                "id": str(holding.cryptocurrency.id),
                "symbol": holding.cryptocurrency.symbol,
                "name": holding.cryptocurrency.name,
                "icon_url": holding.cryptocurrency.icon_url,
                "current_price": holding.cryptocurrency.current_price or Decimal('0'),
                "volume_24h": holding.cryptocurrency.volume_24h,
                "market_cap": holding.cryptocurrency.market_cap
            },
            "quantity": holding.quantity,
            "average_purchase_price": holding.average_purchase_price,
            "total_cost_basis": holding.total_cost_basis,
            "current_value": holding.current_value,
            "gain_loss": holding.gain_loss,
            "gain_loss_percentage": holding.gain_loss_percentage
        })

    return {"holdings": holdings_data}


# Cryptocurrency Endpoints

@router.get("/cryptocurrencies", response=List[CryptocurrencySchema], tags=["Cryptocurrencies"])
def get_cryptocurrencies(request):
    """
    Get all available cryptocurrencies with current market data.

    Returns a list of all active cryptocurrencies available for trading, including
    current prices, 24h changes, volume, and market cap from CoinGecko.

    Endpoint:
        GET /api/cryptocurrencies

    Response Schema:
        List[CryptocurrencySchema] - See trading/schemas.py:CryptocurrencySchema

    Response Fields (per cryptocurrency):
        - id (str): Cryptocurrency UUID
        - symbol (str): Trading symbol (e.g., BTC, ETH)
        - name (str): Full name (e.g., Bitcoin, Ethereum)
        - coingecko_id (str): CoinGecko API identifier
        - icon_url (str): Logo image URL
        - category (str): Asset category (CRYPTO, STABLECOIN, DEFI, NFT, MEME)
        - current_price (Decimal): Latest USD price (8 decimals, defaults to 0)
        - price_change_24h (Decimal): 24h percentage change (2 decimals, defaults to 0)
        - volume_24h (Decimal): 24h trading volume USD (2 decimals, defaults to 0)
        - market_cap (Decimal): Market cap USD (2 decimals, defaults to 0)
        - last_updated (datetime): Last price update timestamp (timezone-aware, nullable)

    Error Codes:
        - None (always returns 200 with array, even if empty)

    External Service Calls:
        - None (uses cached cryptocurrency.current_price from database)
        - Prices updated by background worker (update_prices.py management command)

    Performance:
        - Single database query with WHERE is_active=True
        - No JOINs or external API calls
        - Typical response time: <100ms

    Example Response:
        [
            {
                "id": "uuid-string",
                "symbol": "BTC",
                "name": "Bitcoin",
                "coingecko_id": "bitcoin",
                "icon_url": "https://...",
                "category": "CRYPTO",
                "current_price": "42000.00",
                "price_change_24h": "2.35",
                "volume_24h": "28500000000.00",
                "market_cap": "820000000000.00",
                "last_updated": "2025-01-15T14:30:00Z"
            },
            ...
        ]

    Notes:
        - Used by CryptocurrencyList.js (Market page) and TradeModal
        - is_active filter excludes deprecated/delisted cryptocurrencies
        - Null prices default to 0 (graceful degradation if price update fails)
    """
    cryptos = Cryptocurrency.objects.filter(is_active=True).all()

    return [
        {
            "id": str(crypto.id),
            "symbol": crypto.symbol,
            "name": crypto.name,
            "coingecko_id": crypto.coingecko_id,
            "icon_url": crypto.icon_url,
            "category": crypto.category,
            "current_price": crypto.current_price or Decimal('0'),
            "price_change_24h": crypto.price_change_24h or Decimal('0'),
            "volume_24h": crypto.volume_24h or Decimal('0'),
            "market_cap": crypto.market_cap or Decimal('0'),
            "last_updated": crypto.last_updated
        }
        for crypto in cryptos
    ]


@router.get("/cryptocurrencies/{crypto_id}", response=CryptocurrencyDetailSchema, tags=["Cryptocurrencies"])
def get_cryptocurrency_detail(request, crypto_id: str):
    """
    Get detailed cryptocurrency information with 7-day price history.

    Returns comprehensive details for a single cryptocurrency including current market
    data and a 7-day price history sparkline from CoinGecko.

    Endpoint:
        GET /api/cryptocurrencies/{crypto_id}

    Path Parameters:
        - crypto_id (str, required): Cryptocurrency UUID

    Response Schema:
        CryptocurrencyDetailSchema - See trading/schemas.py:CryptocurrencyDetailSchema

    Response Fields:
        - All CryptocurrencySchema fields (id, symbol, name, prices, etc.)
        - price_history_7d (List): 7-day price history for sparkline chart:
          [
              {
                  "timestamp": datetime (timezone-aware UTC),
                  "price": Decimal (USD, 8 decimals)
              },
              ...
          ]

    Error Codes:
        - 404: Cryptocurrency not found (invalid crypto_id)
        - 502: CoinGecko service failure (upstream API down/rate limited)

    External Service Calls:
        - CoinGeckoService.get_historical_prices(coingecko_id, 7)
        - Rate limits: Free tier ~10-50 calls/min, Pro tier ~500 calls/min
        - 1 API call per request

    Performance:
        - Single database query (get_object_or_404)
        - 1 CoinGecko API call for 7-day history
        - Typical response time: 200-500ms

    Example Response:
        {
            "id": "uuid-string",
            "symbol": "BTC",
            "name": "Bitcoin",
            "coingecko_id": "bitcoin",
            "icon_url": "https://...",
            "category": "CRYPTO",
            "current_price": "42000.00",
            "price_change_24h": "2.35",
            "volume_24h": "28500000000.00",
            "market_cap": "820000000000.00",
            "last_updated": "2025-01-15T14:30:00Z",
            "price_history_7d": [
                {"timestamp": "2025-01-08T00:00:00Z", "price": "40500.00"},
                {"timestamp": "2025-01-09T00:00:00Z", "price": "41000.00"},
                ...
            ]
        }

    Notes:
        - Used by ViewChartModal.js for detailed asset view with sparkline
        - 7-day history typically returns 7 data points (daily intervals)
        - Empty price_history_7d if CoinGecko call fails (graceful degradation)
    """
    crypto = get_object_or_404(Cryptocurrency, id=crypto_id)

    # Get 7-day price history
    coingecko_service = CoinGeckoService()
    price_history = coingecko_service.get_historical_prices(crypto.coingecko_id, 7)

    return {
        "id": str(crypto.id),
        "symbol": crypto.symbol,
        "name": crypto.name,
        "coingecko_id": crypto.coingecko_id,
        "icon_url": crypto.icon_url,
        "category": crypto.category,
        "current_price": crypto.current_price,
        "price_change_24h": crypto.price_change_24h,
        "volume_24h": crypto.volume_24h,
        "market_cap": crypto.market_cap,
        "last_updated": crypto.last_updated,
        "price_history_7d": price_history
    }


# Trading Endpoints

@router.post("/trades/buy", response=TradeResponseSchema, tags=["Trading"])
def execute_buy(request, payload: BuyRequestSchema):
    """
    Execute a BUY order for cryptocurrency with balance validation.

    Purchases cryptocurrency using portfolio cash at current market price, updates
    holdings with weighted average cost basis, and returns transaction record with
    updated portfolio balance.

    Endpoint:
        POST /api/trades/buy

    Request Body (BuyRequestSchema):
        {
            "cryptocurrency_id": str (UUID, required),
            "amount_usd": Decimal (optional, mutually exclusive with quantity),
            "quantity": Decimal (optional, mutually exclusive with amount_usd)
        }

    Request Rules:
        - Either amount_usd OR quantity must be provided (not both, not neither)
        - If amount_usd: quantity calculated as amount_usd / current_price
        - If quantity: amount_usd calculated as quantity × current_price

    Response Schema:
        TradeResponseSchema - See trading/schemas.py:TradeResponseSchema

    Success Response:
        {
            "success": true,
            "transaction": {
                "id": str (UUID),
                "type": "BUY",
                "cryptocurrency": {"symbol": str, "name": str, "icon_url": str},
                "quantity": Decimal (8 decimals),
                "price_per_unit": Decimal (8 decimals),
                "total_amount": Decimal (2 decimals),
                "timestamp": datetime (timezone-aware),
                "realized_gain_loss": "0.00" (always 0 for BUY)
            },
            "updated_portfolio": {
                "cash_balance": Decimal (2 decimals),
                "total_portfolio_value": Decimal (2 decimals)
            },
            "error": null
        }

    Error Response:
        {
            "success": false,
            "transaction": null,
            "updated_portfolio": null,
            "error": str (error message)
        }

    Error Codes:
        - 404: Cryptocurrency not found (invalid cryptocurrency_id)
        - 200 with success=false: Validation failure (see error field):
          • "No user found"
          • "Cryptocurrency price not available"
          • "Insufficient funds. Available: $X, Required: $Y"
          • "Minimum trade amount is $0.01"
          • "Must provide either amount_usd or quantity"
          • "Trade execution failed: {exception}"

    Validations (via TradingService.execute_buy):
        - Cryptocurrency must have current_price available
        - Portfolio must have sufficient cash_balance >= amount_usd
        - Minimum trade amount: $0.01 USD
        - Either amount_usd OR quantity required (not both)

    Transaction Guarantees:
        - Atomic operation (all-or-nothing via transaction.atomic())
        - Rollback on any error (portfolio, holdings, transaction records)
        - No partial updates

    Cost Basis Tracking:
        - New holding: average_purchase_price = current_price
        - Existing holding: weighted average cost basis updated
        - Formula: new_avg = (old_cost + amount_usd) / (old_qty + quantity)

    Example Request:
        # Buy $100 worth of Bitcoin
        POST /api/trades/buy
        {
            "cryptocurrency_id": "uuid-string",
            "amount_usd": "100.00"
        }

        # Buy 0.5 ETH
        POST /api/trades/buy
        {
            "cryptocurrency_id": "uuid-string",
            "quantity": "0.5"
        }

    Notes:
        - Used by TradeModal.js for buy trades
        - Instant execution at cryptocurrency.current_price (no order queuing)
        - No fees or slippage (simplified sandbox model)
        - Demo user: User.objects.first() (sandbox assumption)
        - See services/trading.py:TradingService.execute_buy for full logic
    """
    user = User.objects.first()
    if not user:
        return {
            "success": False,
            "error": "No user found"
        }

    portfolio = user.portfolio
    crypto = get_object_or_404(Cryptocurrency, id=payload.cryptocurrency_id)

    success, transaction, error = TradingService.execute_buy(
        portfolio=portfolio,
        cryptocurrency=crypto,
        amount_usd=payload.amount_usd,
        quantity=payload.quantity
    )

    if not success:
        return {
            "success": False,
            "error": error
        }

    # Refresh portfolio
    portfolio.refresh_from_db()

    return {
        "success": True,
        "transaction": {
            "id": str(transaction.id),
            "type": transaction.transaction_type,
            "cryptocurrency": {
                "symbol": crypto.symbol,
                "name": crypto.name,
                "icon_url": crypto.icon_url
            },
            "quantity": transaction.quantity,
            "price_per_unit": transaction.price_per_unit,
            "total_amount": transaction.total_amount,
            "timestamp": transaction.timestamp,
            "realized_gain_loss": transaction.realized_gain_loss
        },
        "updated_portfolio": {
            "cash_balance": portfolio.cash_balance,
            "total_portfolio_value": portfolio.total_value
        }
    }


@router.post("/trades/sell", response=TradeResponseSchema, tags=["Trading"])
def execute_sell(request, payload: SellRequestSchema):
    """
    Execute a SELL order for cryptocurrency with holdings validation and realized P&L.

    Sells cryptocurrency from portfolio holdings at current market price, calculates
    realized gain/loss using weighted average cost basis, updates holdings/portfolio,
    and returns transaction record with P&L.

    Endpoint:
        POST /api/trades/sell

    Request Body (SellRequestSchema):
        {
            "cryptocurrency_id": str (UUID, required),
            "amount_usd": Decimal (optional, mutually exclusive with quantity),
            "quantity": Decimal (optional, mutually exclusive with amount_usd)
        }

    Request Rules:
        - Either amount_usd OR quantity must be provided (not both, not neither)
        - If amount_usd: quantity calculated as amount_usd / current_price
        - If quantity: amount_usd calculated as quantity × current_price

    Response Schema:
        TradeResponseSchema - See trading/schemas.py:TradeResponseSchema

    Success Response:
        {
            "success": true,
            "transaction": {
                "id": str (UUID),
                "type": "SELL",
                "cryptocurrency": {"symbol": str, "name": str, "icon_url": str},
                "quantity": Decimal (8 decimals),
                "price_per_unit": Decimal (8 decimals, current market price),
                "total_amount": Decimal (2 decimals, proceeds),
                "timestamp": datetime (timezone-aware),
                "realized_gain_loss": Decimal (2 decimals, can be negative)
            },
            "updated_portfolio": {
                "cash_balance": Decimal (2 decimals),
                "total_portfolio_value": Decimal (2 decimals)
            },
            "error": null
        }

    Error Response:
        {
            "success": false,
            "transaction": null,
            "updated_portfolio": null,
            "error": str (error message)
        }

    Error Codes:
        - 404: Cryptocurrency not found (invalid cryptocurrency_id)
        - 200 with success=false: Validation failure (see error field):
          • "No user found"
          • "Cryptocurrency price not available"
          • "You don't own any {symbol}"
          • "Insufficient holdings. You own: X, Requested: Y"
          • "Must provide either amount_usd or quantity"
          • "Trade execution failed: {exception}"

    Validations (via TradingService.execute_sell):
        - Cryptocurrency must have current_price available
        - Holding must exist for this cryptocurrency
        - Portfolio must have sufficient holdings: quantity <= holding.quantity
        - Either amount_usd OR quantity required (not both)

    Transaction Guarantees:
        - Atomic operation (all-or-nothing via transaction.atomic())
        - Rollback on any error (portfolio, holdings, transaction records)
        - No partial updates

    Realized P&L Calculation:
        - Formula: realized_gain_loss = (current_price - avg_purchase_price) × quantity_sold
        - Uses holding's weighted average cost basis
        - Positive: profit, Negative: loss
        - Calculated BEFORE updating holdings

    Holdings Update:
        - Full sell (quantity == holding.quantity): Holding deleted
        - Partial sell: quantity and cost basis reduced, average_price unchanged

    Example Request:
        # Sell $500 worth of Ethereum
        POST /api/trades/sell
        {
            "cryptocurrency_id": "uuid-string",
            "amount_usd": "500.00"
        }

        # Sell 1.5 SOL
        POST /api/trades/sell
        {
            "cryptocurrency_id": "uuid-string",
            "quantity": "1.5"
        }

    Example Success Response:
        {
            "success": true,
            "transaction": {
                "id": "uuid",
                "type": "SELL",
                "cryptocurrency": {"symbol": "ETH", "name": "Ethereum", "icon_url": "..."},
                "quantity": "0.25",
                "price_per_unit": "2000.00",
                "total_amount": "500.00",
                "timestamp": "2025-01-15T14:30:00Z",
                "realized_gain_loss": "125.00"  // Profit of $125
            },
            "updated_portfolio": {
                "cash_balance": "9750.50",
                "total_portfolio_value": "12671.25"
            }
        }

    Notes:
        - Used by TradeModal.js for sell trades
        - Instant execution at cryptocurrency.current_price (no order queuing)
        - No fees or slippage (simplified sandbox model)
        - Demo user: User.objects.first() (sandbox assumption)
        - Realized P&L stored in Transaction.realized_gain_loss field
        - See services/trading.py:TradingService.execute_sell for full logic
    """
    user = User.objects.first()
    if not user:
        return {
            "success": False,
            "error": "No user found"
        }

    portfolio = user.portfolio
    crypto = get_object_or_404(Cryptocurrency, id=payload.cryptocurrency_id)

    success, transaction, error = TradingService.execute_sell(
        portfolio=portfolio,
        cryptocurrency=crypto,
        amount_usd=payload.amount_usd,
        quantity=payload.quantity
    )

    if not success:
        return {
            "success": False,
            "error": error
        }

    # Refresh portfolio
    portfolio.refresh_from_db()

    return {
        "success": True,
        "transaction": {
            "id": str(transaction.id),
            "type": transaction.transaction_type,
            "cryptocurrency": {
                "symbol": crypto.symbol,
                "name": crypto.name,
                "icon_url": crypto.icon_url
            },
            "quantity": transaction.quantity,
            "price_per_unit": transaction.price_per_unit,
            "total_amount": transaction.total_amount,
            "timestamp": transaction.timestamp,
            "realized_gain_loss": transaction.realized_gain_loss
        },
        "updated_portfolio": {
            "cash_balance": portfolio.cash_balance,
            "total_portfolio_value": portfolio.total_value
        }
    }


# Transaction History Endpoints

@router.get("/transactions", response=List[TransactionSchema], tags=["Transactions"])
@paginate(PageNumberPagination, page_size=20)
def get_transactions(
    request,
    type: Optional[str] = Query(None, description="Filter by type: ALL, BUY, SELL")
):
    """
    Get transaction history with pagination and optional type filtering.

    Returns a paginated list of the user's historical buy/sell transactions, ordered by
    timestamp descending (most recent first). Supports filtering by transaction type.

    Endpoint:
        GET /api/transactions?type={type}&page={page}

    Query Parameters:
        - type (str, optional): Filter by transaction type. Values:
          • ALL (default): Returns both BUY and SELL transactions
          • BUY: Only buy transactions
          • SELL: Only sell transactions
        - page (int, optional): Page number for pagination (default 1)

    Pagination:
        - Page size: 20 transactions per page
        - Implemented via PageNumberPagination

    Response Schema:
        List[TransactionSchema] - See trading/schemas.py:TransactionSchema
        Note: Wrapped in pagination envelope by django-ninja

    Response Fields (per transaction):
        - id (str): Transaction UUID
        - type (str): Transaction type (BUY or SELL)
        - cryptocurrency (object): Asset details (symbol, name, icon_url)
        - quantity (Decimal): Crypto amount traded (8 decimals)
        - price_per_unit (Decimal): Execution price (8 decimals)
        - total_amount (Decimal): USD value (2 decimals)
        - timestamp (datetime): Trade execution time (timezone-aware, descending order)
        - realized_gain_loss (Decimal): P&L for SELL transactions (2 decimals, 0 for BUY)

    Error Codes:
        - None (returns empty array if no user or no transactions)

    Performance:
        - select_related('cryptocurrency') prevents N+1 queries
        - Indexed by portfolio_id and timestamp for fast sorting
        - Page size limit (20) prevents large result sets

    Example Response (paginated):
        {
            "count": 45,
            "next": "http://api/transactions?page=2",
            "previous": null,
            "results": [
                {
                    "id": "uuid",
                    "type": "SELL",
                    "cryptocurrency": {"symbol": "BTC", "name": "Bitcoin", "icon_url": "..."},
                    "quantity": "0.05",
                    "price_per_unit": "42000.00",
                    "total_amount": "2100.00",
                    "timestamp": "2025-01-15T14:30:00Z",
                    "realized_gain_loss": "200.00"
                },
                ...
            ]
        }

    Notes:
        - Used by Portfolio.js Transactions tab
        - Transactions ordered by timestamp DESC (most recent first)
        - Empty array if no user found (graceful degradation)
        - Demo user: User.objects.first() (sandbox assumption)
    """
    user = User.objects.first()
    if not user:
        return []

    portfolio = user.portfolio
    transactions = Transaction.objects.filter(portfolio=portfolio).select_related('cryptocurrency')

    # Filter by type
    if type and type != 'ALL':
        transactions = transactions.filter(transaction_type=type)

    return [
        {
            "id": str(txn.id),
            "type": txn.transaction_type,
            "cryptocurrency": {
                "symbol": txn.cryptocurrency.symbol,
                "name": txn.cryptocurrency.name,
                "icon_url": txn.cryptocurrency.icon_url
            },
            "quantity": txn.quantity,
            "price_per_unit": txn.price_per_unit,
            "total_amount": txn.total_amount,
            "timestamp": txn.timestamp,
            "realized_gain_loss": txn.realized_gain_loss
        }
        for txn in transactions
    ]


# News Endpoints

@router.get("/news/crypto", response=List[NewsArticleSchema], tags=["News"])
def get_crypto_news(
    request,
    limit: int = Query(10, description="Number of articles to return (default 10)")
):
    """
    Get cryptocurrency news articles from Finnhub with HTML sanitization.

    Returns a list of the latest cryptocurrency news articles from Finnhub's /news
    endpoint, sorted by datetime descending (newest first), with HTML tags stripped
    from summaries.

    Endpoint:
        GET /api/news/crypto?limit={limit}

    Query Parameters:
        - limit (int, optional): Number of articles to return (default 10, max depends on Finnhub response)

    Response Schema:
        List[NewsArticleSchema] - See trading/schemas.py:NewsArticleSchema

    Response Fields (per article):
        - id (int): Unique article identifier from Finnhub
        - datetime (int): Publication timestamp (UNIX seconds)
        - headline (str): Article title
        - image (str): Image URL (may be empty string)
        - summary (str): Article summary with HTML tags stripped and entities decoded
        - url (str): Full article URL
        - source (str): News source name (may be empty string)

    HTML Sanitization:
        - HTML tags removed (e.g., <p>, <a>, <br>)
        - HTML entities decoded (e.g., &nbsp; → space, &amp; → &)
        - Extra whitespace normalized

    Error Codes:
        - 502: Finnhub service failure (upstream API down/rate limited/auth error)
          Error message: "Upstream news provider error: {details}"

    External Service Calls:
        - FinnhubService.get_crypto_news(limit)
        - Rate limits: Free tier 60 calls/min, Premium tier higher
        - 1 API call per request

    Performance:
        - No database writes (read-only external API call)
        - Typical response time: 200-500ms
        - Articles cached in Finnhub service (if implemented)

    Example Response:
        [
            {
                "id": 123456,
                "datetime": 1705334400,
                "headline": "Bitcoin Surges Past $42,000 Amid ETF Approval",
                "image": "https://...",
                "summary": "Bitcoin prices jumped 5% following SEC approval of spot ETF applications...",
                "url": "https://...",
                "source": "CoinDesk"
            },
            ...
        ]

    Notes:
        - Used by News.js page via useCryptoNews.js hook
        - Articles may contain empty image or source fields (optional)
        - Filtering by min_id supported in FinnhubService but not exposed here
        - Finnhub API key kept server-side (settings.FINNHUB_API_KEY)
        - See services/finnhub.py for full implementation details
    """
    try:
        finnhub_service = FinnhubService()
        articles = finnhub_service.get_crypto_news(limit=limit)
        return articles
    except Exception as e:
        # Map upstream errors to 502 (Bad Gateway), not 500
        raise HttpError(502, f"Upstream news provider error: {str(e)}")


# User Endpoints

@router.get("/user/account", response=UserAccountSchema, tags=["User"])
def get_user_account(request):
    """
    Get current user's account and personal information.

    Returns the demo user's profile including personal details (name, contact, address)
    and account metadata (account number, account type). Null fields should be displayed
    as "N/A" on the frontend.

    Endpoint:
        GET /api/user/account

    Response Schema:
        UserAccountSchema - See trading/schemas.py:UserAccountSchema

    Response Fields:
        Personal Information:
        - first_name (str | null): User's first name
        - last_name (str | null): User's last name
        - username (str): Username (required, unique)
        - email (str): Email address (required)
        - date_of_birth (date | null): Birth date (YYYY-MM-DD format)
        - address (str | null): Street address
        - city (str | null): City name
        - state (str | null): State/province
        - zip_code (str | null): Postal code
        - country (str | null): Country name

        Account Information:
        - account_number (str | null): Account identifier
        - account_type (str | null): Account type (e.g., "Individual", "Business")

    Error Codes:
        - 404: No user found (empty database)

    Performance:
        - Single database query (User.objects.first())
        - No JOINs or external API calls
        - Typical response time: <50ms

    Example Response:
        {
            "first_name": "John",
            "last_name": "Doe",
            "username": "demo_user",
            "email": "demo@example.com",
            "date_of_birth": "1990-01-15",
            "address": "123 Main St",
            "city": "San Francisco",
            "state": "CA",
            "zip_code": "94102",
            "country": "USA",
            "account_number": "ACC123456",
            "account_type": "Individual"
        }

    Null Field Handling:
        {
            "first_name": null,
            "last_name": null,
            ...
        }
        // Frontend displays as "N/A" per Account.js component

    Notes:
        - Used by Account.js page for user profile display
        - Demo user: User.objects.first() (sandbox assumption)
        - Null fields valid (user may not have provided all personal info)
        - No authentication required (sandbox demo mode)
    """
    # Get demo user (same pattern as /portfolio/summary)
    user = User.objects.first()
    if not user:
        raise HttpError(404, "No user found")

    return {
        # Personal Information
        "first_name": user.first_name,
        "last_name": user.last_name,
        "username": user.username,
        "email": user.email,
        "date_of_birth": user.date_of_birth,
        "address": user.address,
        "city": user.city,
        "state": user.state,
        "zip_code": user.zip_code,
        "country": user.country,
        # Account Information
        "account_number": user.account_number,
        "account_type": user.account_type,
    }


# Market Endpoints

@router.get("/price_history", tags=["Market"])
def price_history(request, symbol: str, period: str = "1y", interval: str = "1d"):
    """
    Fetch historical price and volume data for a symbol via yfinance (Yahoo Finance).

    Returns time-series price/volume data for cryptocurrencies or stocks using yfinance
    library. Supports multiple timeframes with automatic interval overrides for intraday
    periods. Forward-fills missing close prices and formats timestamps for charting.

    Endpoint:
        GET /api/price_history?symbol={symbol}&period={period}&interval={interval}

    Query Parameters:
        - symbol (str, required): Trading symbol (e.g., BTC-USD, ETH-USD, AAPL)
          • Cryptocurrency symbols: Add "-USD" suffix (e.g., BTC-USD, ETH-USD)
          • Stock symbols: Use ticker directly (e.g., AAPL, TSLA)
        - period (str, optional): Lookback period (default "1y"). Valid values:
          • 1d, 5d, 1mo, 3mo, 6mo, 1y, 2y, 5y, 10y, ytd, max
        - interval (str, optional): Data interval (default "1d"). Valid values:
          • 1m, 2m, 5m, 15m, 30m, 60m, 90m, 1h, 1d, 5d, 1wk, 1mo, 3mo
          • Note: Overridden for periods 1d/5d (see Interval Overrides)

    Interval Overrides:
        - period="1d": interval auto-set to "5m" (5-minute intraday)
        - period="5d": interval auto-set to "15m" (15-minute intraday)
        - Other periods: Use provided interval parameter

    Response Format:
        Success (200):
        {
            "symbol": str (uppercase),
            "period": str (normalized lowercase),
            "interval": str (normalized lowercase),
            "count": int (number of data points),
            "data": [
                {
                    "date": str (YYYY-MM-DD, always included),
                    "datetime": str (YYYY-MM-DD HH:MM, intraday only),
                    "close": float (forward-filled close price),
                    "volume": int (trading volume)
                },
                ...
            ]
        }

        Error (200 with error field):
        {
            "symbol": str,
            "period": str,
            "interval": str,
            "count": 0,
            "data": [],
            "error": str (error message),
            "details": str (exception details, if applicable)
        }

    Data Processing:
        - Forward-fill: Missing close prices filled with previous value
        - Timestamp conversion: yfinance timestamps converted to strings
        - Timezone handling: Converts to tz-naive (strips timezone)
        - Intraday detection: period in ("1d", "5d") adds "datetime" field

    Error Cases:
        - No data found: symbol invalid or no data for period/interval
        - Missing timestamp column: yfinance response format unexpected
        - Parse failure: Cannot convert timestamps to datetime
        - Missing columns: "Close" or "Volume" not in yfinance response
        - Exception: General failure (network, invalid symbol, etc.)

    External Service Calls:
        - yfinance library (Yahoo Finance API)
        - Rate limits: None documented (unofficial API)
        - 1 API call per request

    Performance:
        - Typical response time: 500ms-2s (depends on period/interval)
        - Large periods (5y, max) may be slower
        - No database writes (read-only external API call)

    Example Requests:
        # 1-year daily data for Bitcoin
        GET /api/price_history?symbol=BTC-USD&period=1y&interval=1d

        # 1-day 5-minute intraday data for Ethereum (interval auto-overridden)
        GET /api/price_history?symbol=ETH-USD&period=1d

        # 5-year weekly data for Apple stock
        GET /api/price_history?symbol=AAPL&period=5y&interval=1wk

    Example Success Response:
        {
            "symbol": "BTC-USD",
            "period": "1y",
            "interval": "1d",
            "count": 365,
            "data": [
                {
                    "date": "2024-01-15",
                    "close": 42000.50,
                    "volume": 28500000000
                },
                ...
            ]
        }

    Example Intraday Response:
        {
            "symbol": "BTC-USD",
            "period": "1d",
            "interval": "5m",
            "count": 78,
            "data": [
                {
                    "date": "2025-01-15",
                    "datetime": "2025-01-15 09:30",
                    "close": 42100.00,
                    "volume": 1200000
                },
                ...
            ]
        }

    Example Error Response:
        {
            "symbol": "INVALID",
            "period": "1y",
            "interval": "1d",
            "count": 0,
            "data": [],
            "error": "No historical data found for symbol 'INVALID' with period '1y' and interval '1d'"
        }

    Notes:
        - Used by ViewChartModal.js for cryptocurrency/stock price charts
        - Symbol mapping: BTC → BTC-USD, ETH → ETH-USD (handled by frontend)
        - yfinance is unofficial Yahoo Finance API (no rate limits but may break)
        - Error responses return 200 status with error field (not 4xx/5xx)
        - Server logs errors to console for debugging (print statement)
    """
    try:
        # Normalize overrides for intraday periods
        period_norm = period.strip().lower()
        interval_norm = interval.strip().lower()

        if period_norm == "1d":
            interval_norm = "5m"
        elif period_norm == "5d":
            interval_norm = "15m"

        # Fetch history
        ticker = yf.Ticker(symbol)
        df = ticker.history(period=period_norm, interval=interval_norm)

        if df.empty:
            return {
                "symbol": symbol.upper(),
                "period": period_norm,
                "interval": interval_norm,
                "count": 0,
                "data": [],
                "error": f"No historical data found for symbol '{symbol}' with period '{period_norm}' and interval '{interval_norm}'",
            }

        # Reset index to expose Date/Datetime as a column
        df = df.reset_index()

        # Identify the timestamp column provided by yfinance
        ts_col = "Datetime" if "Datetime" in df.columns else "Date" if "Date" in df.columns else None
        if not ts_col:
            return {
                "symbol": symbol.upper(),
                "period": period_norm,
                "interval": interval_norm,
                "count": 0,
                "data": [],
                "error": "No timestamp column found in yfinance response",
            }

        # Ensure timestamp is a datetime dtype (tz-naive)
        ts = pd.to_datetime(df[ts_col], errors="coerce")
        if ts.isna().all():
            return {
                "symbol": symbol.upper(),
                "period": period_norm,
                "interval": interval_norm,
                "count": 0,
                "data": [],
                "error": "Failed to parse timestamps from yfinance response",
            }
        if getattr(ts.dt, "tz", None) is not None:
            ts = ts.dt.tz_convert(None)

        # Always provide 'date' (YYYY-MM-DD)
        df["date"] = ts.dt.strftime("%Y-%m-%d")

        # Provide 'datetime' only for intraday requests (1d/5d)
        is_intraday = period_norm in ("1d", "5d")
        if is_intraday:
            # YYYY-MM-DD HH:MM (no seconds)
            df["datetime"] = ts.dt.strftime("%Y-%m-%d %H:%M")

        # Forward-fill Close if needed, then pick Close and Volume
        if "Close" not in df.columns or "Volume" not in df.columns:
            return {
                "symbol": symbol.upper(),
                "period": period_norm,
                "interval": interval_norm,
                "count": 0,
                "data": [],
                "error": "Expected columns 'Close' and/or 'Volume' not present in yfinance response",
            }

        df["Close"] = df["Close"].ffill()

        # Build the clean payload
        keep_cols = ["date", "Close", "Volume"]
        if is_intraday:
            keep_cols.insert(1, "datetime")  # ["date","datetime","Close","Volume"]

        df_clean = df[keep_cols].copy()
        df_clean.rename(columns={"Close": "close", "Volume": "volume"}, inplace=True)

        # Convert to native Python types safe for JSON
        data = df_clean.to_dict(orient="records")

        return {
            "symbol": symbol.upper(),
            "period": period_norm,
            "interval": interval_norm,
            "count": len(data),
            "data": data,
        }

    except Exception as e:
        # Log for server visibility and return a clean error payload
        print(f"Error fetching price data for {symbol} ({period}/{interval}): {e}")
        return {
            "symbol": symbol.upper(),
            "period": period,
            "interval": interval,
            "error": "Failed to fetch price data",
            "details": str(e),
            "data": [],
        }
